# onMeasure方法核心是设置系统的两个全局变量 width和height
  
  1.onMeasure(int widthMeasureSpec, int heightMeasureSpec) 函数调用可知，需要知道widthMeasureSpec和heightMeasureSpec
  
  2.他们两个高两位代表宽高的模式，低30位代表大小
  
  3.模式对应在xml文件中定义的layout_witdth＝ “match_parent”
  
  4.大小对应需要计算
  
  5.由此在调用这个函数之前需要确定widthMeasureSpec和heightMeasureSpec两个值
  
  6.而这两个值是由父容器的MeasureSpec和自己的LayoutParams决定，这是由ViewGroup类的measureChildWithMargins决定
  
  7.默认请看下这两个值会传入onMeasure方法，并设置前面说的全局变量
  
  8.那么这两个值是如何确定的，由里面的getChildMeasureSpec方法获取，这里只说出结果
    
    1.当view的大小采用固定值时，无论无容器的measureSpec是什么，view的大小都是确定值，而且模式是精确模式
    
    2.当view的模式采用match_parent时，如果父容器是精确模式，那么view也是精确模式，大小是parentSize，
      
      当父容器是最大模式，view是最大模式，大小要么是parentSize或者是childSize， 哪个小算哪个
      
    3.当view采用wrap_content的时候，无论父容器是什么模式，view都是最大化模式，大小都为parentSize，，
    
    ====>进而出现一个问题，如果我们采用wrap_contnet模式时，会发现，我们自定义的控件的大小值，为parentSize，也就是说它会填满整个父容器，如果
    
    父容器中还有别的控件无论在其前面还说后面都会被它覆盖
    
  9.从8中可以得出6的结论
  
  10.当这两个值确定后，默认的view的onMeasure方法仅仅是两个全局变量值的设置
    
  11.
